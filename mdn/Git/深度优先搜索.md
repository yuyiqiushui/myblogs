# 深度优先搜索

- ## 剑指offer-29:  顺时针打印矩阵

  - Description

  - Idea

    方法一：模拟

    可以模拟打印矩阵的路径。初始位置是矩阵左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向

    

    判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。

    ​	

    如何判断路径是否已经结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

    ​	

    复杂度分析：

    - 时间复杂度： O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次
    - 空间复杂度： O(mn)，需要创建一个大小为 m ✖️ n 的矩阵 visited 记录每个位置是否被访问过 

    

    方法二：按层模拟

    可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。

    

    定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第一层，次外层都是第二层，剩下的元素都是第三层

    

    ```
    [
    [1,1,1,1,1],
    [1,2,2,2,1],
    [1,2,3,2,1],
    [1,2,2,2,1],
    [1,1,1,1,1]
    ]
    ```

    ​	

    对于每层，从左上方开始以顺时针遍历所有元素。假设当前层的左上角位于 (top, left)，右下角位于 (bottom, right)，按照如下顺序遍历当前层的元素。

    ​	

    1、从左到右遍历上侧元素，依次为 (top, left) 到 (top, right).

    2、从上到下遍历右侧元素，依次为 (top+1, right) 到 (bottom, right)。

    3、如果 left < right 且 top < bottom, 则从右到左遍历下侧元素，依次为 (bottom, right-1)到 (bottom, left+1)，以及从下到上遍历左侧元素，依次为 (bottom, left)到(top+1, left)

    ​	

    遍历完当前层的元素之后，将left 和 top分别增加 1，将 right 和 bottom 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。

    ​	

    ![](http://cdn.yuyiqiushui.cn/leetcode29.png)

  - Code

  

  

- ## 剑指 offer 10-II.青蛙跳台阶问题

  - Description:

  一只青蛙一次可以跳上1级台阶，也可以跳上两级台阶。求该青蛙跳上一个 n 级台阶有多少种跳法。

  答案需要取模  1e9+7 (1000000007), 如计算初始结果为：1000000008，请返回1.

  - idea

    - 设跳上 n 级台阶有 f(n) 种跳法，青蛙的最后一步只有两种情况： 跳上 1 级或 2级台阶。

      1. 当为 1级台阶： 剩 n-1 个台阶，此情况共有 f(n-1)种跳法；
      2. 当为 2级台阶： 剩 n-2个台阶，此情况共有  f(n-2)种跳法；

    - f(n)为以上两种情况之和，即 f(n) = f(n-1) + f(n-2)，以上递推性质为斐波那契数列。本题可转化为 **求斐波那契数列第 n 项的值**，与 面试题 10-1.斐波那契数列 等价，唯一不同在于起始数字不同。

      1. 青蛙跳台阶问题： f(0) = 1, f(1) = 1, f(2) = 2;

      2. 斐波那契数列问题： f(0) = 0, f(1) = 1, f(2) = 1; 

         ![](http://cdn.yuyiqiushui.cn/leetcode10.png)

         > 斐波那契数列的定义是 f(n+1) = f(n) + f(n-1)，生成第 n 项的做法有以下几种：
         >
         > 1. 递归法：
         >    - 原理： 把 f(n) 问题的计算拆分成 f(n-1) 和 f(n-2)两个子问题的计算，并递归，以 f(0) 和 f(1)为终止条件。
         >    - 缺点： 大量重复的递归计算，例如 f(n) 和 f(n-1) 两者向下递归都需要计算 f(n-2)的值。
         > 2. 记忆化递归法：
         >    - 原理：在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字时则直接从数组取用，避免了重复的递归计算。
         >    - 缺点：记忆化存储的数组需要使用 O(N) 的额外空间
         > 3. 动态规划：
         >    - 原理： 以斐波那契数列性质 f(n+1) = f(n) + f(n-1) 为转移方程
         >    - 从计算效率、空间复杂度上看，动态规划是本题的最佳解法

         **动态规划解析**

         - 状态定义：设 dp 为一维数组，其中 dp[i] 的值代表 `斐波那契数列第 $i$ 个数字 `
         - 转移方程： dp[i+1] = dp[i] + dp[i-1], 即对应数列定义 f(n+1) = f(n) + f(n-1);
         - 初始状态： dp[0] = 1, dp[1] = 1, 即初始化前两个数字；
         - 返回值：dp[n], 即斐波那契数列的第 n 个数字

         **空间复杂度优化**

         > 若新建长度为 n 的 dp 列表，则空间复杂度为 O(N).

         - 由于 dp l列表第 i 项只与第 i - 1 和 第 i - 2项有关，因此只需要初始化三个整型变量 `sum`  , `a`  ,  `b`  ,  利用了辅助变量 sum 使 a, b 两数字交替前进即可 (具体实现见代码)。
         - 因为节省了 dp 列表空间，因此空间复杂度降至 O(1).

         **循环求余法**

         > 大数越界： 随着 n 增大，f(n)会超过  `Int32` 甚至 `Int64` 的取值范围，导致最终的返回值错误。

         - 求余运算规则：设正整数 x, y, p, 求余符号为 ⊙，则有 (x + y) ⊙ p = (x⊙p + y⊙p)⊙p。
         - 解析：根据以上规则，可推出 f(n)⊙p = [f(n - 1) ⊙ p + f(n - 2) ⊙ p] ⊙ p，从而可以在循环过程中每次计算 sum = a + b ⊙ 1000000007, 此操作与最终返回前取余等价。

         > 图解基于 Java 代码绘制，Python 由于语言特性可以省去 sum 辅助变量和大数越界处理。

         ![](http://cdn.yuyiqiushui.cn/leetcode101.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode102.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode102.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode103.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode104.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode105.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode106.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode107.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode108.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode109.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode1010.png)

         ![](http://cdn.yuyiqiushui.cn/leetcode1011.png)

         **复杂度分析**

         - 时间复杂度O(N)：计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1).
         - 空间复杂度O(1)： 几个标志变量使用常数大小的额外空间。

         

  - code

- ## 剑指 Offer 59 - II.队列的最大值

  - Description

    请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数 `max_value` 得到队列里的最大值，要求函数 `max_value`、 `push_back`、和 `pop_front` 的均摊时间3复杂度都是 O(1)。

    ​	

    若队列为空， `pop_front` 和 `max_value` 需要返回 -1

  - Idea

    **方法一：暴力**

    直接实现一个普通的队列，查询最大值时遍历计算

    **复杂度分析**

    - 时间复杂度：O(1)  (插入、删除)，O(n). (求最大值)

      插入与删除只需要普通的队列操作，为 O(1), 求最大值需要遍历当前的整个队列，最坏情况下为 O(n)

    - 空间复杂度：O(n)，需要用队列存储所有插入的元素。

     

    **方法二：维护一个单调的双端队列**

    本算法基于问题的一个重要性质：当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响

     

    举个例子，如果我们向队列中插入数字序列  `1 1 1 1 2`，那么在第一个数字 2 被插入后，数字 2 前面的所有数字 1 将不会对结果产生影响。因为按照队列的取出顺序，数字 2 只能在所有的数字 1 被取出之后才能被取出，因此如果数字 1 如果在队列中，那么数字 2 也必然在队列中，使得数字 1 对结果没有影响。

    ​	

    按照上面的思路，我们可以设计这样的方法： 从队列尾部插入元素时，我们可以提前取出队列中所有比这个元素小的元素，使得队列中只保留对结果有影响的数字。这样的方法等价于要求维持队列单调递减，即要保证每个元素的前面都没有比它小的元素。

    ​	

    那么如何高效实现一个始终递减的队列呢？我们只需要在插入每一个元素 `value` 时，从队列尾部依次取出比当前元素 `value` 小的元素，直到遇到一个比当前元素大的元素 `value` 即可。

     

    - 上面的过程保证了只要在元素 `value` 被插入之前队列递减，那么在 `value` 被插入之后队列依然递减
    - 而队列的初始状态 (空队列) 符合单调递减的定义
    - 由数学归纳法可知队列将会始终保持单调递减

     

    上面的过程需要从队列尾部取出元素，因此需要使用双端队列来实现。另外我们也需要一个辅助队列来记录所有被插入的值，以确定 `pop_front` 函数的返回值。

     

    保证了队列的单调递减后，求最大值时只需要直接取双端队列中的第一项即可。

     

    **复杂度分析**

    - 时间复杂度：O(1) (插入，删除，求最大值)

      删除操作于求最大值操作显然只需要O(1)的时间。

      而插入操作虽然看起来有循环，做一个插入操作时最多可能会有 n 次出队操作。但要注意，由于每个数字只会出队一次，因此对于所有的 n 个数字的插入过程，对应的所有出队操作也不会大于 n 次。因此将出队的时间均摊到每个插入操作上，时间复杂度为 O(1).

    - 空间复杂度：O(n)，需要用队列存储所有插入的元素。

     

    

  - Code

- 

  